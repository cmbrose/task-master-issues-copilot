/**
 * Pull Request Comment Manager
 * 
 * Handles posting and managing task graph preview comments on pull requests.
 * Ensures no spam by replacing existing preview comments.
 */

import * as core from '@actions/core';
import { Octokit } from '@octokit/rest';
import { components } from "@octokit/openapi-types";
import { formatTaskGraphMarkdown, formatCompactTaskGraphSummary, TaskGraph, MarkdownFormatterOptions } from './markdown-formatter';

// GitHub API types
type ApiComment = components["schemas"]["issue-comment"];

/**
 * Configuration for PR comment management
 */
export interface PrCommentConfig {
  /** GitHub token for authentication */
  token: string;
  /** Repository owner */
  owner: string;
  /** Repository name */
  repo: string;
  /** Pull request number */
  prNumber: number;
  /** Debug logging */
  debug?: boolean;
}

/**
 * Unique identifier to mark our preview comments
 */
const PREVIEW_COMMENT_MARKER = '<!-- taskmaster-preview-comment -->';
const PREVIEW_COMMENT_FOOTER = `\n\n---\n*ðŸ¤– This preview was automatically generated by Taskmaster. It will be updated when the task graph changes.*\n${PREVIEW_COMMENT_MARKER}`;

/**
 * Pull Request Comment Manager
 */
export class PrCommentManager {
  private octokit: Octokit;
  private config: PrCommentConfig;

  constructor(config: PrCommentConfig) {
    this.config = config;
    this.octokit = new Octokit({
      auth: config.token,
      log: config.debug ? {
        debug: core.debug,
        info: core.info,
        warn: core.warning,
        error: core.error
      } : undefined
    });
  }

  /**
   * Find existing preview comment on the PR
   */
  private async findExistingPreviewComment(): Promise<ApiComment | null> {
    try {
      const { data: comments } = await this.octokit.rest.issues.listComments({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: this.config.prNumber,
        per_page: 100 // Get more comments to ensure we find our marker
      });

      // Find comment with our marker
      const existingComment = comments.find(comment => 
        comment.body && comment.body.includes(PREVIEW_COMMENT_MARKER)
      );

      if (existingComment) {
        core.info(`Found existing preview comment #${existingComment.id}`);
        return existingComment;
      }

      return null;
    } catch (error) {
      core.warning(`Failed to fetch PR comments: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * Create a new preview comment
   */
  private async createPreviewComment(body: string): Promise<ApiComment> {
    try {
      const { data: comment } = await this.octokit.rest.issues.createComment({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: this.config.prNumber,
        body: body + PREVIEW_COMMENT_FOOTER
      });

      core.info(`Created new preview comment #${comment.id} on PR #${this.config.prNumber}`);
      return comment;
    } catch (error) {
      const errorMessage = `Failed to create preview comment: ${error instanceof Error ? error.message : String(error)}`;
      core.error(errorMessage);
      throw new Error(errorMessage);
    }
  }

  /**
   * Update existing preview comment
   */
  private async updatePreviewComment(commentId: number, body: string): Promise<ApiComment> {
    try {
      const { data: comment } = await this.octokit.rest.issues.updateComment({
        owner: this.config.owner,
        repo: this.config.repo,
        comment_id: commentId,
        body: body + PREVIEW_COMMENT_FOOTER
      });

      core.info(`Updated existing preview comment #${commentId} on PR #${this.config.prNumber}`);
      return comment;
    } catch (error) {
      const errorMessage = `Failed to update preview comment #${commentId}: ${error instanceof Error ? error.message : String(error)}`;
      core.error(errorMessage);
      throw new Error(errorMessage);
    }
  }

  /**
   * Delete existing preview comment
   */
  private async deletePreviewComment(commentId: number): Promise<void> {
    try {
      await this.octokit.rest.issues.deleteComment({
        owner: this.config.owner,
        repo: this.config.repo,
        comment_id: commentId
      });

      core.info(`Deleted preview comment #${commentId} on PR #${this.config.prNumber}`);
    } catch (error) {
      core.warning(`Failed to delete preview comment #${commentId}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Post or update task graph preview comment on PR
   */
  async postTaskGraphPreview(
    taskGraph: TaskGraph, 
    options: Partial<MarkdownFormatterOptions> = {}
  ): Promise<{ commentId: number; isNew: boolean }> {
    core.info(`Posting task graph preview to PR #${this.config.prNumber}`);

    try {
      // Generate markdown content
      const markdownContent = formatTaskGraphMarkdown(taskGraph, options);
      
      // Check if we have an existing comment to replace
      const existingComment = await this.findExistingPreviewComment();
      
      if (existingComment) {
        // Update existing comment
        const updatedComment = await this.updatePreviewComment(existingComment.id, markdownContent);
        return { commentId: updatedComment.id, isNew: false };
      } else {
        // Create new comment
        const newComment = await this.createPreviewComment(markdownContent);
        return { commentId: newComment.id, isNew: true };
      }
    } catch (error) {
      const errorMessage = `Failed to post task graph preview: ${error instanceof Error ? error.message : String(error)}`;
      core.setFailed(errorMessage);
      throw new Error(errorMessage);
    }
  }

  /**
   * Post a compact summary comment (for smaller PRs or as fallback)
   */
  async postCompactSummary(taskGraph: TaskGraph): Promise<{ commentId: number; isNew: boolean }> {
    core.info(`Posting compact task graph summary to PR #${this.config.prNumber}`);

    try {
      const summary = formatCompactTaskGraphSummary(taskGraph);
      const content = `## ðŸš€ Task Graph Preview\n\n${summary}\n\n` +
                     `<details>\n<summary>ðŸ“‹ Click to see full task breakdown</summary>\n\n` +
                     `${formatTaskGraphMarkdown(taskGraph, { useCollapsibleSections: true })}\n</details>`;

      // Check if we have an existing comment to replace
      const existingComment = await this.findExistingPreviewComment();
      
      if (existingComment) {
        // Update existing comment
        const updatedComment = await this.updatePreviewComment(existingComment.id, content);
        return { commentId: updatedComment.id, isNew: false };
      } else {
        // Create new comment
        const newComment = await this.createPreviewComment(content);
        return { commentId: newComment.id, isNew: true };
      }
    } catch (error) {
      const errorMessage = `Failed to post compact summary: ${error instanceof Error ? error.message : String(error)}`;
      core.setFailed(errorMessage);
      throw new Error(errorMessage);
    }
  }

  /**
   * Remove any existing preview comments (cleanup)
   */
  async removePreviewComments(): Promise<number> {
    core.info(`Removing preview comments from PR #${this.config.prNumber}`);

    try {
      const { data: comments } = await this.octokit.rest.issues.listComments({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: this.config.prNumber,
        per_page: 100
      });

      // Find all comments with our marker
      const previewComments = comments.filter(comment => 
        comment.body && comment.body.includes(PREVIEW_COMMENT_MARKER)
      );

      // Delete all preview comments
      for (const comment of previewComments) {
        await this.deletePreviewComment(comment.id);
      }

      core.info(`Removed ${previewComments.length} preview comment(s) from PR #${this.config.prNumber}`);
      return previewComments.length;
    } catch (error) {
      core.warning(`Failed to remove preview comments: ${error instanceof Error ? error.message : String(error)}`);
      return 0;
    }
  }

  /**
   * Check if PR has changes to PRD files (to decide if we should post preview)
   */
  async hasPrdChanges(): Promise<boolean> {
    try {
      const { data: files } = await this.octokit.rest.pulls.listFiles({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: this.config.prNumber,
        per_page: 100
      });

      // Check if any files match PRD patterns
      const prdFilePatterns = [
        /\.prd\.md$/i,
        /docs\/.*\.prd\.md$/i,
        /.*\/.*\.prd\.md$/i
      ];

      const hasPrdChanges = files.some(file => 
        prdFilePatterns.some(pattern => pattern.test(file.filename))
      );

      core.info(`PR #${this.config.prNumber} has PRD changes: ${hasPrdChanges}`);
      return hasPrdChanges;
    } catch (error) {
      core.warning(`Failed to check PR file changes: ${error instanceof Error ? error.message : String(error)}`);
      return false; // Assume no PRD changes if we can't check
    }
  }

  /**
   * Get PR information for context
   */
  async getPrInfo(): Promise<{
    title: string;
    author: string;
    baseBranch: string;
    headBranch: string;
    changedFiles: number;
  } | null> {
    try {
      const { data: pr } = await this.octokit.rest.pulls.get({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: this.config.prNumber
      });

      return {
        title: pr.title,
        author: pr.user?.login || 'unknown',
        baseBranch: pr.base.ref,
        headBranch: pr.head.ref,
        changedFiles: pr.changed_files || 0
      };
    } catch (error) {
      core.warning(`Failed to get PR info: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
}

/**
 * Helper function to create and configure PR comment manager
 */
export function createPrCommentManager(config: PrCommentConfig): PrCommentManager {
  return new PrCommentManager(config);
}

/**
 * Helper function to post task graph preview with automatic formatting options
 */
export async function postTaskGraphPreview(
  taskGraph: TaskGraph,
  config: PrCommentConfig,
  options: Partial<MarkdownFormatterOptions> = {}
): Promise<{ commentId: number; isNew: boolean }> {
  const manager = createPrCommentManager(config);
  
  // Check if PR has PRD changes
  const hasPrdChanges = await manager.hasPrdChanges();
  if (!hasPrdChanges) {
    core.info('PR does not contain PRD changes, skipping preview comment');
    throw new Error('No PRD changes detected in PR');
  }

  // Auto-adjust options based on task graph size
  const taskCount = taskGraph.tasks?.length || 0;
  const autoOptions: Partial<MarkdownFormatterOptions> = {
    useCollapsibleSections: taskCount > 5, // Use collapsible for large graphs
    includeDetails: taskCount <= 10, // Show details only for smaller graphs
    maxDisplayDepth: taskCount > 20 ? 2 : 3, // Reduce depth for very large graphs
    ...options
  };

  // Use compact format for very large task graphs
  if (taskCount > 15) {
    return await manager.postCompactSummary(taskGraph);
  } else {
    return await manager.postTaskGraphPreview(taskGraph, autoOptions);
  }
}